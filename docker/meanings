36Ô∏è‚É£ How do you optimize Dockerfile layer caching?
Answer:

Docker builds images layer by layer and caches each layer.

To optimize caching:

1. Put frequently changing instructions at the bottom

Example:

COPY . .   ‚Üê changes frequently ‚Üí should be lower

2. Put dependency install steps at the top
COPY package*.json ./
RUN npm install


Then:

COPY . .


This allows Docker to reuse cached npm install layer.

3. Use .dockerignore

Prevents unnecessary files from breaking cache.

4. Combine RUN instructions
RUN apt-get update && apt-get install -y curl

5. Avoid ADD . . with large contexts
Interview answer (Short):

Place stable steps at the top and changing steps at the bottom so Docker can reuse cached layers to speed up builds.


How do you debug a failed Docker build?
Steps:
1. Use verbose output
docker build . --progress=plain

2. Identify the exact layer failing

Docker prints step numbers like:

Step 4/8 : RUN npm install


Fix issues in that layer.

3. Use an interactive shell inside intermediate container
docker run -it <intermediate-image-id> sh

4. Check build context

Run:

docker build . --no-cache


If it succeeds ‚Üí caching issue.

5. Validate Dockerfile syntax
docker run --rm -i hadolint/hadolint < Dockerfile


(Static analysis helper)

‚≠ê Interview summary:

I check which step fails, inspect intermediate containers, rebuild with no cache, and validate the Dockerfile.

‚úÖ 39Ô∏è‚É£ How do you troubleshoot a container not starting?
Steps:
1. Check logs
docker logs <container>

2. Inspect container
docker inspect <container>

3. Check exit code
docker ps -a


Common exit codes:

1 ‚Üí application error

137 ‚Üí killed due to OOM (memory limit)

126/127 ‚Üí command not found

0 ‚Üí container ran and exited normally

4. Check ENTRYPOINT / CMD issues

If ENTRYPOINT is wrong ‚Üí container exits immediately.

5. Run container shell manually
docker run -it <image> sh

6. Check file permissions / user issues
7. If running in Kubernetes
kubectl describe pod


Look for:

OOMKilled

CrashLoopBackOff

Permission denied errors

‚≠ê Interview Short Answer:

Check logs, inspect container, verify ENTRYPOINT/CMD, check exit codes, and run the image interactively to test.

‚úÖ 40Ô∏è‚É£ Why does a container exit immediately after starting?
Reason:

The container‚Äôs main process finished, so Docker stops it.

Docker containers run as long as the main process (PID 1) runs.

Common causes:

Running commands that exit immediately

docker run ubuntu echo "hello"


Finishes ‚Üí container stops.

ENTRYPOINT / CMD misconfigured

Wrong script path

Missing file

Permission denied

No foreground process
If app runs in background (&) ‚Üí container exits.

Using base images like alpine without a command

docker run alpine
if needs to run continuesly use CMD ["tail", "-f", "/dev/null"]


No default command ‚Üí exits.

Shell script ends due to error

‚≠ê Interview summary:

Containers exit when the main process finishes. To keep them running, ensure a long-running process like a server or use tail -f /dev/null.

41Ô∏è‚É£ What does Exit Code 137, 143, 1, and 0 mean in Docker?
Exit Code 0

‚úî Success ‚Äî container completed without errors.

Exit Code 1

‚ùå General application error
Reasons:

Script error

File missing

Wrong command

Node/Java/Python app crashed

Exit Code 137

‚ùó Container was killed due to OOM (Out Of Memory)

Means the kernel terminated the container

Usually occurs when a container exceeds memory limit

Kubernetes shows:

OOMKilled


Fix: Increase container memory or fix memory leaks.

Exit Code 143

‚ö†Ô∏è Container stopped gracefully (SIGTERM)

Occurs when:

You run docker stop

Pod is terminated during deployment

Graceful shutdown in Kubernetes

üß† Interview Summary:

137 = OOM Killed, 143 = stopped gracefully, 1 = error, 0 = success.


How to integrate Docker build + push to ACR in YAML?
trigger:
- main

pool:
  vmImage: ubuntu-latest

variables:
  imageName: myapp

steps:
- task: Docker@2
  inputs:
    command: build
    repository: $(imageName)
    dockerfile: Dockerfile
    tags: |
      $(Build.BuildId)

- task: Docker@2
  inputs:
    command: login
    containerRegistry: myACRServiceConnection

- task: Docker@2
  inputs:
    command: push
    repository: $(imageName)
    tags: |
      $(Build.BuildId)
